<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dance</title>
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.2/dist/posenet.min.js"></script>
    <script>
        // Warte auf PoseNet, bevor wir starten
        window.addEventListener('load', () => {
            console.log('Window geladen, PoseNet verfügbar:', typeof posenet !== 'undefined');
        });
    </script>
    <style>
        @font-face {
            font-family: 'DEM-MOMono-300';
            src: url('DEM-MO typeface/Mono/DEM-MOMono-300.otf') format('opentype');
            font-weight: 300;
            font-style: normal;
        }

        @font-face {
            font-family: 'DEM-MOMono-400';
            src: url('DEM-MO typeface/Mono/DEM-MOMono-400.otf') format('opentype');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Info Button */
        .info-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: #000000;
            color: #ffffff;
            border: none;
            border-radius: 0;
            font-family: 'DEM-MOMono-300', monospace;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .info-button:hover {
            background-color: #333333;
        }

        /* Home Button */
        .home-button {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: #000000;
            color: #ffffff;
            border: none;
            border-radius: 0;
            font-family: 'DEM-MOMono-300', monospace;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .home-button:hover {
            background-color: #333333;
        }

        /* Floating Info Window */
        .info-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10001;
            justify-content: center;
            align-items: center;
        }

        .info-overlay.active {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .info-window {
            background-color: #ffffff;
            width: 80%;
            max-width: 780px;
            max-height: 90vh;
            position: relative;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            font-family: 'DEM-MOMono-400', monospace;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .info-window p {
            font-family: 'DEM-MOMono-400', monospace;
            line-height: 1.6;
        }

        .info-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background-color: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .info-close:hover {
            color: #666666;
        }

        body {
            background-color: #ffffff;
            display: flex;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            border-right: 2px solid #000000; /* Vertikale Trennlinie */
            min-width: 220px; /* Breite für Quadrate + Padding */
            flex-shrink: 0;
        }

        .left-panel .image-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px; /* Breite wie Quadrate */
        }

        .left-panel .video-text,
        .left-panel .stickman-text,
        .left-panel .image-text {
            width: 200px; /* Breite wie Quadrate */
            font-family: 'DEM-MOMono-300', monospace;
            text-align: center;
            font-size: 12px;
        }

        .left-panel .video-play-pause-controls,
        .left-panel .video-frame-controls {
            width: 200px; /* Breite wie Quadrate */
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 11px;
        }

        .left-panel .video-play-pause-controls input[type="range"],
        .left-panel .video-frame-controls button {
            width: 100%;
            font-size: 11px;
            padding: 3px 5px;
        }

        .left-panel .video-frame-controls {
            flex-wrap: wrap;
        }

        .left-panel .video-frame-controls button {
            flex: 1 1 auto;
            min-width: 80px;
        }

        .main-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
            padding-left: 20px; /* Gleicher Abstand wie links vom Menü */
            padding-right: 20px; /* Gleicher Abstand rechts zum Bildschirmrand */
        }

        .grid-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
            width: 650px; /* Feste, kleinere Breite */
        }

        .left-panel .recording-window {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px; /* Breite wie andere Quadrate */
        }

        .left-panel .recording-text {
            width: 200px;
            font-family: 'DEM-MOMono-300', monospace;
            text-align: center;
            font-size: 12px;
        }

        .left-panel .grid-recording-controls {
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 11px;
        }

        .left-panel .recording-inputs {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .left-panel .recording-inputs label,
        .left-panel .recording-inputs input,
        .left-panel .recording-inputs button {
            font-size: 11px;
            padding: 3px 5px;
            width: 100%;
        }

        .left-panel #recordingStatus {
            font-size: 10px;
        }

        .image-window,
        .video-window,
        .stickman-window {
            width: 100%;
            max-width: 200px; /* 1/3 von 600px */
            aspect-ratio: 1 / 1;
            border: 2px solid #000000; /* Border auch proportional kleiner */
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(16, 1fr); /* Flexible Spalten */
            grid-auto-rows: auto;
            gap: 1px; /* Zurück zu kleinerem Gap */
            background-color: #000000;
            padding: 1px; /* Zurück zu kleinerem Padding */
            border: 1px solid #000000; /* Zurück zu kleinerem Border */
            margin-bottom: 5px;
            box-sizing: border-box;
            transition: background-color 0.3s, border-color 0.3s;
            width: 650px; /* Feste Breite */
        }

        .grid-container.inverted {
            background-color: #ffffff;
            border-color: #ffffff;
        }

        .grid-cell {
            background-color: #ffffff;
            width: 100%;
            aspect-ratio: 2 / 1; /* Verhältnis 2:1 (Breite:Höhe) wie 32px:16px */
            box-sizing: border-box;
            transition: none;
        }

        .grid-cell.inverted {
            background-color: #000000;
        }

        .grid-cell.active.inverted {
            background-color: #000000;
        }

        .image-window,
        .video-window,
        .stickman-window {
            background-color: #ffffff;
            position: relative;
            overflow: hidden;
        }

        .image-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }

        .image-drop-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px dashed #cccccc;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s, background-color 0.3s;
            z-index: 2;
        }

        .image-drop-area:hover {
            border-color: #000000;
        }

        .image-drop-area.dragover {
            border-color: #000000;
            background-color: #f0f0f0;
        }

        .image-drop-area.has-image {
            /* Drop-Area bleibt sichtbar und aktiv, damit man ein neues Video per Drag-and-Drop einfügen kann */
            border: 2px dashed #cccccc;
            pointer-events: auto;
            z-index: 10;
            opacity: 0.3;
            transition: opacity 0.3s, border-color 0.3s;
        }

        .image-drop-area.has-image:hover,
        .image-drop-area.has-image.dragover {
            opacity: 1;
            border-color: #000000;
        }

        .image-text,
        .video-text,
        .stickman-text {
            font-family: 'DEM-MOMono-300', monospace;
            text-align: center;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .video-zoom-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-family: 'DEM-MOMono-300', monospace;
            font-size: 14px;
        }
        
        .video-zoom-controls label {
            font-family: 'DEM-MOMono-300', monospace;
        }
        
        .video-zoom-controls input[type="range"] {
            width: 150px;
            cursor: pointer;
        }
        
        .video-zoom-controls span {
            min-width: 50px;
            text-align: left;
        }
        
        .video-frame-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-family: 'DEM-MOMono-300', monospace;
            font-size: 14px;
        }
        
        .video-frame-controls button {
            font-family: 'DEM-MOMono-300', monospace;
            padding: 5px 10px;
            cursor: pointer;
            border: 1px solid #000000;
            background-color: #ffffff;
        }
        
        .video-frame-controls button:hover {
            background-color: #f0f0f0;
        }
        
        .video-frame-controls span {
            min-width: 120px;
            text-align: center;
        }
        
        .grid-recording-controls {
            padding: 15px;
            border: 2px solid #000000;
            background-color: #ffffff;
            width: 100%;
            max-width: 300px;
            flex-shrink: 0;
        }
        
        .recording-inputs {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .recording-inputs label {
            font-family: 'DEM-MOMono-300', monospace;
            font-size: 14px;
        }
        
        .recording-inputs input[type="number"] {
            font-family: 'DEM-MOMono-300', monospace;
        }
        
        .recording-inputs button {
            font-family: 'DEM-MOMono-300', monospace;
            padding: 5px 15px;
            cursor: pointer;
            border: 1px solid #000000;
            background-color: #ffffff;
        }
        
        .recording-inputs button:hover {
            background-color: #f0f0f0;
        }
        
        #recordingStatus {
            font-family: 'DEM-MOMono-300', monospace;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }

        .image-wrapper,
        .video-wrapper {
            cursor: pointer;
        }

        .image-input,
        .video-input {
            display: none;
        }

        .image-container,
        .video-container,
        .stickman-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            overflow: hidden;
        }

        .image-item,
        .video-item {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .image-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        .video-item video {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            width: 1px;
            height: 1px;
        }
        
        .video-item canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            transition: transform 0.1s ease;
        }

        .image-grid-container,
        .video-grid-container,
        .stickman-grid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(16, 2fr);
            grid-template-rows: repeat(32, 1fr);
            gap: 0;
            z-index: 0;
        }

        .image-grid-cell,
        .video-grid-cell,
        .stickman-grid-cell {
            width: 100%;
            height: 100%;
            background-color: transparent;
            border: none;
        }
        
        .stickman-item {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .stickman-item canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background-color: #ffffff;
        }
    </style>
</head>
<body>
    <!-- Info Button -->
    <button class="info-button" id="infoButton">i</button>
    
    <!-- Home Button -->
    <a href="file:///Users/eazy-e/Documents/UNI/HSD/3_SEMESTER/PUB/technoooo/TECHNOTOOLS.html" class="home-button" id="homeButton">⌂</a>

    <!-- Info Floating Window -->
    <div class="info-overlay" id="infoOverlay">
        <div class="info-window">
            <button class="info-close" id="infoClose">×</button>
            <p>This interactive website turns dance videos into digital art. Upload a video of yourself or others dancing in a techno frenzy and transform the movements into a dancing pixel character. You can save the individual frames as PNG or PDF, or record and export your own video from the animation.</p>
        </div>
    </div>
    <div class="left-panel">
    <div class="image-wrapper">
        <div class="video-window" id="videoWindow">
            <div class="video-grid-container" id="videoGridContainer"></div>
            <div class="image-drop-area" id="videoDropArea">
                <input type="file" id="videoInput" class="video-input" accept="video/*">
            </div>
            <div class="video-container" id="videoContainer"></div>
        </div>
        <div class="video-text">
            Drag video here or click to select
        </div>
        <div class="video-frame-controls" id="videoPlayPauseControls" style="display: none;">
                <button id="videoPlayPauseBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%;">⏸ Pause</button>
        </div>
        <div class="video-frame-controls" id="videoFrameControls" style="display: none;">
                <button id="prevFrameBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer;">◀ Prev</button>
                <span id="frameInfo" style="font-family: 'DEM-MOMono-300', monospace; font-size: 11px;">Frame: 0 / 0</span>
                <button id="nextFrameBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer;">Next ▶</button>
                <button id="saveFramesPNGBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%;">Save as PNG</button>
                <button id="saveFramesJPEGBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%;">Save Frames as JPEG</button>
                <button id="blackModeBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%;">Black</button>
            </div>
        </div>
        
        <div class="image-wrapper">
        <div class="stickman-window" id="stickmanWindow">
            <div class="stickman-grid-container" id="stickmanGridContainer"></div>
            <div class="stickman-container" id="stickmanContainer"></div>
        </div>
        <div class="stickman-text">
            Stickman
            </div>
        </div>
        
        <div class="recording-window">
            <div class="grid-recording-controls" id="gridRecordingControls">
                <div class="recording-inputs">
                    <button id="selectFolderBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%;">Select Folder</button>
                    <span id="folderStatus" style="font-family: 'DEM-MOMono-300', monospace; font-size: 10px; display: block; margin-top: 5px;"></span>
            </div>
                <div class="recording-inputs" style="margin-top: 5px;">
                    <label for="recordingDuration" style="font-size: 11px;">Duration (s):</label>
                    <input type="number" id="recordingDuration" min="1" max="60" value="5" style="font-family: 'DEM-MOMono-300', monospace; width: 100%; padding: 3px 5px;">
                    <button id="startRecordingBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%; margin-top: 5px;">Start Recording</button>
                    <button id="stopRecordingBtn" style="font-family: 'DEM-MOMono-300', monospace; padding: 3px 5px; cursor: pointer; width: 100%; margin-top: 5px; display: none;">Stop Recording</button>
        </div>
                <div id="recordingStatus" style="font-family: 'DEM-MOMono-300', monospace; margin-top: 5px; text-align: center; font-size: 10px;"></div>
        </div>
            <div class="recording-text">
                Recording
    </div>
        </div>
        </div>
    
    <div class="main-content">
        <div class="grid-wrapper" id="gridWrapper"></div>
    </div>

    <script>
        const gridWrapper = document.getElementById('gridWrapper');
        const columns = 16;
        const totalRows = 24; // Angepasst für 6 Reihen pro Grid (wie in PIXEL.html)
        const rowsPerGrid = 6; // 6 Zeilen pro Grid-Block (wie in PIXEL.html)
        const numGrids = Math.ceil(totalRows / rowsPerGrid); // 4 Grids

        // Erstelle mehrere Grid-Container (Blöcke)
        const gridContainers = [];
        for (let g = 0; g < numGrids; g++) {
            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';
            gridContainer.id = `gridContainer${g}`;
            gridWrapper.appendChild(gridContainer);
            gridContainers.push(gridContainer);

            // Erstelle Zellen für dieses Grid
            const rowsInThisGrid = (g === numGrids - 1) ? (totalRows - g * rowsPerGrid) : rowsPerGrid;
            for (let row = 0; row < rowsInThisGrid; row++) {
            for (let col = 0; col < columns; col++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                    cell.dataset.globalRow = g * rowsPerGrid + row;
                    cell.dataset.col = col;
                    cell.dataset.grid = g;
                gridContainer.appendChild(cell);
            }
        }
        }

        // Hilfsfunktion: Hole alle Grid-Zellen (über alle Grids hinweg)
        function getAllGridCells() {
            return document.querySelectorAll('.grid-cell');
        }

        // Hilfsfunktion: Hole Zelle an globaler Position (row, col)
        function getCellAtGlobalPosition(globalRow, col) {
            return document.querySelector(`.grid-cell[data-global-row="${globalRow}"][data-col="${col}"]`);
        }

        // Erstelle unsichtbares Gitter im Video-Fenster
        const videoGridContainer = document.getElementById('videoGridContainer');
        for (let row = 0; row < totalRows; row++) {
            for (let col = 0; col < columns; col++) {
                const cell = document.createElement('div');
                cell.className = 'video-grid-cell';
                
                videoGridContainer.appendChild(cell);
            }
        }

        // Erstelle unsichtbares Gitter im Stickman-Fenster
        const stickmanGridContainer = document.getElementById('stickmanGridContainer');
        for (let row = 0; row < totalRows; row++) {
            for (let col = 0; col < columns; col++) {
                const cell = document.createElement('div');
                cell.className = 'stickman-grid-cell';
                
                stickmanGridContainer.appendChild(cell);
            }
        }

        // Funktion zum Analysieren des Bildes und Färben des Gitters (wird für Video/Stickman verwendet)
        function analyzeImageAndColorGrid(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Canvas-Größe = Bildgröße
            canvas.width = img.naturalWidth || img.width;
            canvas.height = img.naturalHeight || img.height;
            
            // Zeichne Bild auf Canvas
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Berechne Größe jedes Bereiches
            const cellWidth = canvas.width / columns;
            const cellHeight = canvas.height / totalRows;
            
            // Analysiere jeden Bereich
            for (let row = 0; row < totalRows; row++) {
                for (let col = 0; col < columns; col++) {
                    // Berechne Start-Position des Bereiches
                    const startX = Math.floor(col * cellWidth);
                    const startY = Math.floor(row * cellHeight);
                    const endX = Math.floor((col + 1) * cellWidth);
                    const endY = Math.floor((row + 1) * cellHeight);
                    
                    // Sammle Pixel-Farben in diesem Bereich
                    let totalR = 0, totalG = 0, totalB = 0, pixelCount = 0;
                    
                    // Analysiere einige Pixel (jeden 2. Pixel für Performance)
                    for (let y = startY; y < endY; y += 2) {
                        for (let x = startX; x < endX; x += 2) {
                            const imageData = ctx.getImageData(x, y, 1, 1);
                            const data = imageData.data;
                            totalR += data[0];
                            totalG += data[1];
                            totalB += data[2];
                            pixelCount++;
                        }
                    }
                    
                    // Berechne durchschnittliche Farbe
                    const avgR = Math.floor(totalR / pixelCount);
                    const avgG = Math.floor(totalG / pixelCount);
                    const avgB = Math.floor(totalB / pixelCount);
                    
                    // Berechne Helligkeit (Durchschnitt der RGB-Werte)
                    const brightness = (avgR + avgG + avgB) / 3;
                    
                    // Finde entsprechenden Gitter-Kasten an globaler Position
                    const gridCell = getCellAtGlobalPosition(row, col);
                    
                    if (gridCell) {
                        // Nur tief schwarze Bereiche (Helligkeit < 80) werden schwarz gefärbt
                        // Grautöne und hellere Bereiche bleiben weiß
                        if (brightness < 80 && avgR < 80 && avgG < 80 && avgB < 80) {
                            gridCell.style.backgroundColor = '#000000';
                        } else {
                            gridCell.style.backgroundColor = '#ffffff';
                        }
                    }
                }
            }
        }

        // Video-Fenster Funktionalität
        const videoWindow = document.getElementById('videoWindow');
        const videoDropArea = document.getElementById('videoDropArea');
        const videoInput = document.getElementById('videoInput');
        const videoContainer = document.getElementById('videoContainer');
        
        // Video-Verarbeitung Variablen
        let videoElement = null;
        let isProcessing = false;
        let animationFrameId = null;
        let videoFPS = 30; // Standard FPS, wird später aktualisiert
        let totalFrames = 0;
        let currentFrame = 0;
        let isFrameNavigationMode = false;
        
        // Pose Detection Variablen
        let poseDetector = null;
        let stickmanCanvas = null;
        let stickmanCtx = null;
        let stickmanContainer = document.getElementById('stickmanContainer');
        let lastStickmanTime = 0;
        let isDrawingStickman = false;
        let isBlackMode = false; // Flag für invertierten Modus

        // Klick auf Video-Kasten oder Text öffnet File-Dialog
        videoWindow.addEventListener('click', (e) => {
            if (!videoDropArea.classList.contains('has-image')) {
                videoInput.click();
            }
        });

        // File Input ändert sich
        videoInput.addEventListener('change', (e) => {
            handleVideoFiles(e.target.files);
        });

        // Drag & Drop Events für Video - funktioniert auch wenn bereits ein Video geladen ist
        videoDropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            videoDropArea.classList.add('dragover');
        });

        videoDropArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            videoDropArea.classList.remove('dragover');
        });

        videoDropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            videoDropArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleVideoFiles(e.dataTransfer.files);
            }
        });

        // Auch auf videoWindow und videoContainer für besseres Drag-and-Drop
        videoWindow.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (e.dataTransfer.types.includes('Files')) {
                videoDropArea.classList.add('dragover');
            }
        });

        videoWindow.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            videoDropArea.classList.remove('dragover');
        });

        videoWindow.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            videoDropArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleVideoFiles(e.dataTransfer.files);
            }
        });


        // Starte Video-Analyse für Strichmännchen
        function startVideoAnalysis(video) {
            videoElement = video;
            
            // Funktion zum kontinuierlichen Analysieren
            // Nur bei Video-Frame-Wechseln zeichnen, keine Übergänge zwischen Frames
            function startAnalysisLoop() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                
                let lastVideoFrame = -1;
                let isDrawingFrame = false;
                
                function loop() {
                    // Prüfe auf nahtlosen Loop: Springe zum Anfang kurz bevor das Video endet
                    if (video.duration && video.currentTime >= video.duration - 0.05) {
                        video.currentTime = 0.01;
                        lastVideoFrame = -1; // Reset, damit neuer Frame erkannt wird
                    }
                    
                    if (video.paused || video.ended) {
                        animationFrameId = null;
                        return;
                    }
                    
                    // Berechne aktuellen Video-Frame
                    const currentVideoFrame = Math.floor(video.currentTime * videoFPS);
                    
                    // Nur zeichnen, wenn sich der Video-Frame geändert hat UND kein Frame gerade gezeichnet wird
                    // So werden nur diskrete Frames angezeigt, keine Übergänge
                    if (currentVideoFrame !== lastVideoFrame && !isDrawingFrame) {
                        lastVideoFrame = currentVideoFrame;
                        isDrawingFrame = true;
                        // Zeichne Strichmännchen nur bei Frame-Wechsel
                        drawStickman().finally(() => {
                            isDrawingFrame = false;
                        });
                    }
                    
                    animationFrameId = requestAnimationFrame(loop);
                }
                
                animationFrameId = requestAnimationFrame(loop);
            }
            
            // Nahtloser Loop: Springe zum Anfang kurz bevor das Video endet
            video.addEventListener('timeupdate', () => {
                if (video.duration && video.currentTime >= video.duration - 0.1) {
                    video.currentTime = 0.01;
                }
            });
            
            // Starte Analyse, wenn Video abgespielt wird
            video.addEventListener('play', () => {
                startAnalysisLoop();
            });
            
            // Stoppe Analyse, wenn Video pausiert wird
            video.addEventListener('pause', () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            });
            
            // Stoppe Analyse, wenn Video endet
            video.addEventListener('ended', () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                // Setze alle Zellen zurück auf weiß
                const allGridCells = getAllGridCells();
                allGridCells.forEach(cell => {
                    cell.style.backgroundColor = '#ffffff';
                });
            });
            
            // Aktualisiere bei manuellen Sprüngen
            video.addEventListener('seeked', () => {
                if (!video.paused && !animationFrameId) {
                    startAnalysisLoop();
                } else if (!video.paused) {
                    drawStickman();
                }
            });
        }

        // Funktion zum Verarbeiten der Video-Dateien
        function handleVideoFiles(files) {
            // Lösche vorhandene Videos und räume auf
            const existingVideo = videoContainer.querySelector('video');
            if (existingVideo && existingVideo.src) {
                URL.revokeObjectURL(existingVideo.src);
            }
            videoContainer.innerHTML = '';
            videoElement = null;
            
            // Setze alle Gitter-Kästen zurück auf weiß
            const gridCells = getAllGridCells();
            gridCells.forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
            
            // Stoppe laufende Analyse
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Stoppe Video-Display-Animation
            if (videoDisplayAnimationId) {
                cancelAnimationFrame(videoDisplayAnimationId);
                videoDisplayAnimationId = null;
            }
            
            // Verstecke Frame-Controls wenn vorhanden
            const frameControls = document.getElementById('videoFrameControls');
            if (frameControls) {
                frameControls.style.display = 'none';
            }
            
            // Verstecke Play/Pause-Controls wenn vorhanden
            const playPauseControls = document.getElementById('videoPlayPauseControls');
            if (playPauseControls) {
                playPauseControls.style.display = 'none';
            }
            
            if (files.length > 0) {
                const file = files[0]; // Nur das erste Video
                if (file.type.startsWith('video/')) {
                    const videoUrl = URL.createObjectURL(file);
                    
                    const videoItem = document.createElement('div');
                    videoItem.className = 'video-item';
                    
                    const video = document.createElement('video');
                    video.src = videoUrl;
                    video.controls = false;
                    video.loop = true;
                    video.crossOrigin = 'anonymous';
                    video.muted = true;
                    video.playsInline = true;
                    
                    // Erstelle Canvas für Schwarz-Weiß-Darstellung
                    const videoDisplayCanvas = document.createElement('canvas');
                    videoDisplayCanvas.style.width = '100%';
                    videoDisplayCanvas.style.height = '100%';
                    videoDisplayCanvas.style.objectFit = 'contain';
                    const videoDisplayCtx = videoDisplayCanvas.getContext('2d');
                    
                    // Video unsichtbar machen (wird nur für Pose Detection verwendet)
                    video.style.position = 'absolute';
                    video.style.opacity = '0';
                    video.style.pointerEvents = 'none';
                    video.style.width = '1px';
                    video.style.height = '1px';
                    
                    videoItem.appendChild(video);
                    videoItem.appendChild(videoDisplayCanvas);
                    videoContainer.appendChild(videoItem);
                    
                    // Zeige Play/Pause-Controls
                    const playPauseControls = document.getElementById('videoPlayPauseControls');
                    if (playPauseControls) {
                        playPauseControls.style.display = 'flex';
                    }
                    
                    // Zeige Frame-Controls
                    const frameControls = document.getElementById('videoFrameControls');
                    if (frameControls) {
                        frameControls.style.display = 'flex';
                    }
                    
                    // Initialisiere Play/Pause-Button
                    setupVideoPlayPause(video);
                    
                    // Initialisiere Frame-Navigation
                    setupFrameNavigation(video, videoDisplayCanvas, videoDisplayCtx);
                    
                    // Initialisiere Schwarz-Weiß-Video-Darstellung
                    setupVideoDisplay(video, videoDisplayCanvas, videoDisplayCtx);
                    
                    // Erstelle Stickman-Canvas
                    stickmanContainer.innerHTML = '';
                    const stickmanItem = document.createElement('div');
                    stickmanItem.className = 'stickman-item';
                    
                    stickmanCanvas = document.createElement('canvas');
                    stickmanCanvas.style.width = '100%';
                    stickmanCanvas.style.height = '100%';
                    stickmanCanvas.style.position = 'absolute';
                    stickmanCanvas.style.top = '0';
                    stickmanCanvas.style.left = '0';
                    stickmanCanvas.style.backgroundColor = isBlackMode ? '#000000' : '#ffffff';
                    stickmanCtx = stickmanCanvas.getContext('2d');
                    
                    // Setze initiale Canvas-Größe
                    const stickmanRect = stickmanContainer.getBoundingClientRect();
                    if (stickmanRect.width > 0 && stickmanRect.height > 0) {
                        stickmanCanvas.width = stickmanRect.width;
                        stickmanCanvas.height = stickmanRect.height;
                    }
                    
                    stickmanItem.appendChild(stickmanCanvas);
                    stickmanContainer.appendChild(stickmanItem);
                    
                    console.log('Stickman-Canvas erstellt');
                    
                    // Warte bis Video geladen ist, dann starte Analyse
                    video.addEventListener('loadedmetadata', async () => {
                        console.log('Video Metadaten geladen', video.videoWidth, video.videoHeight);
                        
                        // Berechne FPS und Gesamt-Frames
                        // Versuche FPS aus Video-Qualität zu ermitteln
                        try {
                            if (video.getVideoPlaybackQuality && video.duration > 0) {
                                const quality = video.getVideoPlaybackQuality();
                                if (quality.totalVideoFrames > 0) {
                                    videoFPS = quality.totalVideoFrames / video.duration;
                                }
                            }
                        } catch (e) {
                            console.log('FPS-Berechnung nicht möglich, verwende Standardwert');
                        }
                        
                        // Fallback auf Standard-FPS
                        if (!videoFPS || isNaN(videoFPS) || videoFPS <= 0 || videoFPS > 120) {
                            videoFPS = 30; // Standard-FPS
                        }
                        
                        // Berechne Gesamt-Frames
                        if (video.duration && !isNaN(video.duration) && video.duration > 0) {
                            totalFrames = Math.floor(video.duration * videoFPS);
                        } else {
                            totalFrames = 0;
                        }
                        currentFrame = 0;
                        
                        // Aktualisiere Frame-Info
                        updateFrameInfo();
                        
                        // Initialisiere Pose Detection wenn noch nicht geschehen
                        if (!poseDetector) {
                            await initPoseDetection();
                        }
                        startVideoAnalysis(video);
                    });
                    
                    video.addEventListener('canplay', async () => {
                        console.log('Video kann abgespielt werden');
                        // Zeige ersten Frame
                        if (video.readyState >= video.HAVE_CURRENT_DATA) {
                            currentFrame = 0;
                            video.currentTime = 0;
                            isFrameNavigationMode = true;
                            drawCurrentFrame(video, videoDisplayCanvas, videoDisplayCtx);
                            updateFrameInfo();
                        }
                        // Starte Video automatisch
                        try {
                            isFrameNavigationMode = false;
                            await video.play();
                        } catch (error) {
                            console.log('Automatisches Abspielen nicht möglich:', error);
                            // Bleibe im Frame-Navigationsmodus wenn Video nicht abgespielt werden kann
                            isFrameNavigationMode = true;
                        }
                    });
                    
                    video.addEventListener('error', (e) => {
                        console.error('Video Fehler:', e);
                    });
                    
                    // Markiere dass Video geladen wurde, aber Drop-Area bleibt aktiv für Austausch
                    videoDropArea.classList.add('has-image');
                    // Drop-Area bleibt aktiv, damit man ein neues Video per Drag-and-Drop einfügen kann
                }
            }
        }
        
        // Doppelklick auf Video, um es zu entfernen und neues hochzuladen
        videoContainer.addEventListener('dblclick', () => {
            // Stoppe laufende Analyse
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Lösche URL-Objekt, um Speicher freizugeben
            const videoEl = videoContainer.querySelector('video');
            if (videoEl && videoEl.src) {
                URL.revokeObjectURL(videoEl.src);
            }
            
            videoContainer.innerHTML = '';
            videoElement = null;
            
            // Setze alle Gitter-Kästen zurück auf weiß
            const gridCells = getAllGridCells();
            gridCells.forEach(cell => {
                cell.style.backgroundColor = '#ffffff';
            });
            
            videoDropArea.classList.remove('has-image');
            videoDropArea.style.pointerEvents = 'auto';
            videoInput.value = '';
            
            // Verstecke Play/Pause-Controls
            const playPauseControls = document.getElementById('videoPlayPauseControls');
            if (playPauseControls) {
                playPauseControls.style.display = 'none';
            }
            
            // Verstecke Frame-Controls
            const frameControls = document.getElementById('videoFrameControls');
            if (frameControls) {
                frameControls.style.display = 'none';
            }
            
            // Lösche Stickman-Canvas
            stickmanContainer.innerHTML = '';
            stickmanCanvas = null;
            stickmanCtx = null;
        });
        
        // Initialisiere Pose Detection
        async function initPoseDetection() {
            try {
                console.log('Starte Pose Detection Initialisierung...');
                console.log('PoseNet verfügbar:', typeof posenet !== 'undefined');
                
                if (typeof posenet === 'undefined') {
                    console.error('PoseNet Bibliothek nicht gefunden!');
                    return;
                }
                
                poseDetector = await posenet.load({
                    architecture: 'MobileNetV1',
                    outputStride: 16,
                    inputResolution: 257,
                    multiplier: 0.75
                });
                console.log('Pose Detection erfolgreich initialisiert');
            } catch (error) {
                console.error('Fehler beim Initialisieren der Pose Detection:', error);
            }
        }
        
        // Pose Keypoint Verbindungen für Strichmännchen (PoseNet Keypoint Indizes)
        // 0: nose, 1: leftEye, 2: rightEye, 3: leftEar, 4: rightEar,
        // 5: leftShoulder, 6: rightShoulder, 7: leftElbow, 8: rightElbow,
        // 9: leftWrist, 10: rightWrist, 11: leftHip, 12: rightHip,
        // 13: leftKnee, 14: rightKnee, 15: leftAnkle, 16: rightAnkle
        const POSE_CONNECTIONS = [
            // Linker Arm
            [5, 7], [7, 9],
            // Rechter Arm
            [6, 8], [8, 10],
            // Linkes Bein
            [11, 13], [13, 15],
            // Rechtes Bein
            [12, 14], [14, 16]
        ];
        
        // Funktion zum Zeichnen des Strichmännchens
        async function drawStickman() {
            if (!videoElement || !poseDetector || !stickmanCanvas || isDrawingStickman) return;
            
            // KEINE Rate-Limiting mehr - Animation-Loop kontrolliert bereits die Frame-Rate
            // So werden nur diskrete Frames angezeigt, keine Zwischenzustände mit Grauwerten
            
            if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
                isDrawingStickman = true;
                try {
                    // Erstelle temporären Canvas für Video-Frame
                    const tempCanvas = document.createElement('canvas');
                    let videoWidth = videoElement.videoWidth;
                    let videoHeight = videoElement.videoHeight;
                    
                    if (!videoWidth || !videoHeight) {
                        const videoRect = videoContainer.getBoundingClientRect();
                        videoWidth = videoRect.width;
                        videoHeight = videoRect.height;
                    }
                    
                    tempCanvas.width = videoWidth;
                    tempCanvas.height = videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    // Deaktiviere Interpolation beim Zeichnen des Videos
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Erkenne Pose
                    let pose = null;
                    try {
                        console.log('Starte Pose-Erkennung...');
                        console.log('PoseDetector verfügbar:', !!poseDetector);
                        
                        if (poseDetector) {
                            // PoseNet 2.x API
                            pose = await poseDetector.estimateSinglePose(tempCanvas, {
                                flipHorizontal: false,
                                decodingMethod: 'single-person'
                            });
                            console.log('Pose erkannt:', pose ? 'Ja (' + (pose.keypoints ? pose.keypoints.length : 0) + ' Keypoints)' : 'Nein');
                        } else {
                            console.warn('PoseDetector nicht verfügbar!');
                        }
                    } catch (error) {
                        console.error('Fehler bei Pose-Erkennung:', error);
                    }
                    
                    // Setze Stickman-Canvas Größe
                    const stickmanRect = stickmanContainer.getBoundingClientRect();
                    const canvasWidth = stickmanRect.width || 600;
                    const canvasHeight = stickmanRect.height || 600;
                    
                    stickmanCanvas.width = canvasWidth;
                    stickmanCanvas.height = canvasHeight;
                    
                    // Lösche Canvas und zeichne weißen Hintergrund (immer weiß, unabhängig vom Modus)
                    stickmanCtx.clearRect(0, 0, stickmanCanvas.width, stickmanCanvas.height);
                    stickmanCtx.fillStyle = '#ffffff';
                    stickmanCtx.fillRect(0, 0, stickmanCanvas.width, stickmanCanvas.height);
                    
                    // Stelle sicher, dass Canvas sichtbar ist
                    stickmanCanvas.style.display = 'block';
                    stickmanCanvas.style.visibility = 'visible';
                    
                    if (pose && pose.keypoints && pose.keypoints.length > 0) {
                        const keypoints = pose.keypoints;
                        console.log('Keypoints gefunden:', keypoints.length);
                        
                        // Skaliere Keypoints auf Stickman-Canvas Größe
                        const scaleX = stickmanCanvas.width / tempCanvas.width;
                        const scaleY = stickmanCanvas.height / tempCanvas.height;
                        
                        // Deaktiviere Anti-Aliasing/Interpolation, um Grauwerte zu vermeiden
                        stickmanCtx.imageSmoothingEnabled = false;
                        // Stelle sicher, dass Linien scharf gezeichnet werden (keine abgerundeten Enden)
                        stickmanCtx.lineCap = 'butt'; // Scharfe Enden, keine Rundungen
                        stickmanCtx.lineJoin = 'miter'; // Scharfe Ecken, keine Rundungen
                        stickmanCtx.miterLimit = 1; // Keine abgerundeten Ecken
                        
                        // Strichmännchen ist immer schwarz auf weißem Hintergrund
                        stickmanCtx.strokeStyle = '#000000';
                        stickmanCtx.fillStyle = '#000000';
                        stickmanCtx.lineWidth = 2; // Dünner Körper - nur ein Strich
                        
                        // Zeichne alle Gelenke und Verbindungen
                        // Kopf als ausgefüllter Kreis (basierend auf Nase-Position)
                        const nose = keypoints[0];
                        if (nose && nose.score > 0.3) {
                            const headX = nose.position.x * scaleX;
                            const headY = nose.position.y * scaleY;
                            const headRadius = 10; // Radius für den Kopf
                            
                            stickmanCtx.beginPath();
                            stickmanCtx.arc(headX, headY, headRadius, 0, 2 * Math.PI);
                            stickmanCtx.fill(); // Ausgefüllter Kreis
                        }
                        
                        // Zeichne alle Verbindungen zwischen Gelenken (alle Körperteile)
                        POSE_CONNECTIONS.forEach(([startIdx, endIdx]) => {
                            const startPoint = keypoints[startIdx];
                            const endPoint = keypoints[endIdx];
                            
                            if (startPoint && endPoint && startPoint.score > 0.3 && endPoint.score > 0.3) {
                            stickmanCtx.beginPath();
                                stickmanCtx.moveTo(startPoint.position.x * scaleX, startPoint.position.y * scaleY);
                                stickmanCtx.lineTo(endPoint.position.x * scaleX, endPoint.position.y * scaleY);
                            stickmanCtx.stroke();
                        }
                        });
                        
                        // Zeichne zusätzliche Verbindungen für vollständigen Körper
                        const leftShoulder = keypoints[5];
                        const rightShoulder = keypoints[6];
                        const leftHip = keypoints[11];
                        const rightHip = keypoints[12];
                        
                        // Oberkörper: IMMER ein dünner Strich von Schulter-Mitte zu Hüfte-Mitte (kein Quadrat)
                        if (leftShoulder && rightShoulder && leftHip && rightHip &&
                            leftShoulder.score > 0.3 && rightShoulder.score > 0.3 &&
                            leftHip.score > 0.3 && rightHip.score > 0.3) {
                            const shoulderMidX = ((leftShoulder.position.x + rightShoulder.position.x) / 2) * scaleX;
                            const shoulderMidY = ((leftShoulder.position.y + rightShoulder.position.y) / 2) * scaleY;
                            const hipMidX = ((leftHip.position.x + rightHip.position.x) / 2) * scaleX;
                            const hipMidY = ((leftHip.position.y + rightHip.position.y) / 2) * scaleY;
                            
                            stickmanCtx.beginPath();
                            stickmanCtx.moveTo(shoulderMidX, shoulderMidY);
                            stickmanCtx.lineTo(hipMidX, hipMidY);
                            stickmanCtx.stroke();
                        }
                        
                        // Schultern verbinden
                        if (leftShoulder && rightShoulder && leftShoulder.score > 0.3 && rightShoulder.score > 0.3) {
                                stickmanCtx.beginPath();
                            stickmanCtx.moveTo(leftShoulder.position.x * scaleX, leftShoulder.position.y * scaleY);
                            stickmanCtx.lineTo(rightShoulder.position.x * scaleX, rightShoulder.position.y * scaleY);
                                stickmanCtx.stroke();
                        }
                        
                        // Hüften verbinden
                        if (leftHip && rightHip && leftHip.score > 0.3 && rightHip.score > 0.3) {
                            stickmanCtx.beginPath();
                            stickmanCtx.moveTo(leftHip.position.x * scaleX, leftHip.position.y * scaleY);
                            stickmanCtx.lineTo(rightHip.position.x * scaleX, rightHip.position.y * scaleY);
                            stickmanCtx.stroke();
                        }
                        
                        // Kopf mit Schultern verbinden (von Nase zu Schulter-Mitte)
                        if (nose && leftShoulder && rightShoulder && 
                            nose.score > 0.3 && leftShoulder.score > 0.3 && rightShoulder.score > 0.3) {
                            const shoulderMidX = ((leftShoulder.position.x + rightShoulder.position.x) / 2) * scaleX;
                            const shoulderMidY = ((leftShoulder.position.y + rightShoulder.position.y) / 2) * scaleY;
                            const headX = nose.position.x * scaleX;
                            const headY = nose.position.y * scaleY;
                            
                                stickmanCtx.beginPath();
                            stickmanCtx.moveTo(headX, headY + 10); // Unten am Kopf
                            stickmanCtx.lineTo(shoulderMidX, shoulderMidY);
                                stickmanCtx.stroke();
                            }
                        
                        // Übertrage Strichmännchen auf großes Gitter
                        transferStickmanToGrid();
                    } else {
                        console.log('Keine Pose erkannt oder zu wenige Keypoints');
                        // Wenn keine Pose erkannt, setze Grid zurück auf weiß
                        const gridCells = getAllGridCells();
                        gridCells.forEach(cell => {
                            cell.style.backgroundColor = '#ffffff';
                        });
                    }
                } catch (error) {
                    console.error('Fehler beim Zeichnen des Strichmännchens:', error);
                } finally {
                    isDrawingStickman = false;
                }
            }
        }
        
        // Funktion zum Erstellen einer Maske für die Person basierend auf Pose Keypoints
        function createPersonMask(keypoints, width, height) {
            const mask = new Array(width * height).fill(false);
            
            // Finde Bounding Box der Person basierend auf allen Keypoints
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const validKeypoints = [];
            
            keypoints.forEach(kp => {
                if (kp && kp.score > 0.2) {
                    validKeypoints.push(kp);
                    minX = Math.min(minX, kp.position.x);
                    minY = Math.min(minY, kp.position.y);
                    maxX = Math.max(maxX, kp.position.x);
                    maxY = Math.max(maxY, kp.position.y);
                }
            });
            
            if (validKeypoints.length === 0) {
                return null; // Keine Person erkannt
            }
            
            // Erweitere Bounding Box um Padding für bessere Abdeckung
            const padding = Math.max((maxX - minX) * 0.2, (maxY - minY) * 0.2, 30);
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(width - 1, maxX + padding);
            maxY = Math.min(height - 1, maxY + padding);
            
            // Erstelle konvexe Hülle um alle Keypoints
            // Für einfachere Implementierung: Verwende Ellipse um Bounding Box
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const radiusX = (maxX - minX) / 2;
            const radiusY = (maxY - minY) / 2;
            
            // Fülle Maske innerhalb der Ellipse
            for (let y = Math.floor(minY); y <= Math.ceil(maxY); y++) {
                for (let x = Math.floor(minX); x <= Math.ceil(maxX); x++) {
                    if (x >= 0 && x < width && y >= 0 && y < height) {
                        // Prüfe, ob Punkt innerhalb der Ellipse liegt
                        const dx = (x - centerX) / radiusX;
                        const dy = (y - centerY) / radiusY;
                        if (dx * dx + dy * dy <= 1.1) { // 1.1 für etwas größere Abdeckung
                            mask[y * width + x] = true;
                        }
                    }
                }
            }
            
            // Erweitere Maske um nahe Keypoints (für bessere Abdeckung von Gliedmaßen)
            validKeypoints.forEach(kp => {
                const kpX = Math.floor(kp.position.x);
                const kpY = Math.floor(kp.position.y);
                const expandRadius = 25; // Radius um jeden Keypoint
                
                for (let dy = -expandRadius; dy <= expandRadius; dy++) {
                    for (let dx = -expandRadius; dx <= expandRadius; dx++) {
                        const x = kpX + dx;
                        const y = kpY + dy;
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            if (dx * dx + dy * dy <= expandRadius * expandRadius) {
                                mask[y * width + x] = true;
                            }
                        }
                    }
                }
            });
            
            return mask;
        }
        
        // Funktion zum Übertragen des Strichmännchens auf das große Gitter
        function transferStickmanToGrid() {
            if (!stickmanCanvas || !stickmanCtx) return;
            
            // Hole Pixel-Daten vom Stickman-Canvas
            const imageData = stickmanCtx.getImageData(0, 0, stickmanCanvas.width, stickmanCanvas.height);
            const data = imageData.data;
            
            // Berechne Grid-Zellgröße
            const cellWidth = stickmanCanvas.width / columns;
            const cellHeight = stickmanCanvas.height / totalRows;
            
            // Setze alle Zellen zurück basierend auf Modus
            const allGridCells = getAllGridCells();
            const defaultColor = isBlackMode ? '#000000' : '#ffffff';
            allGridCells.forEach(cell => {
                cell.style.backgroundColor = defaultColor;
            });
            
            // Iteriere über alle Grid-Zellen
            for (let row = 0; row < totalRows; row++) {
                for (let col = 0; col < columns; col++) {
                    const startX = Math.floor(col * cellWidth);
                    const startY = Math.floor(row * cellHeight);
                    const endX = Math.floor((col + 1) * cellWidth);
                    const endY = Math.floor((row + 1) * cellHeight);
                    
                    // Prüfe, ob in diesem Bereich schwarze Pixel sind (Linien des Strichmännchens)
                    let hasBlackPixel = false;
                    
                    for (let y = startY; y < endY && y < stickmanCanvas.height; y++) {
                        for (let x = startX; x < endX && x < stickmanCanvas.width; x++) {
                            const index = (y * stickmanCanvas.width + x) * 4;
                            const r = data[index];
                            const g = data[index + 1];
                            const b = data[index + 2];
                            
                            // Nur vollständig schwarze Pixel (RGB = 0,0,0) werden erkannt
                            if (r === 0 && g === 0 && b === 0) {
                                hasBlackPixel = true;
                                break;
                            }
                        }
                        if (hasBlackPixel) break;
                    }
                    
                    // Wenn schwarze Pixel gefunden, färbe entsprechende Grid-Zelle
                    // Im Black-Modus: schwarze Kästen werden weiß, weiße Kästen werden schwarz
                    if (hasBlackPixel) {
                        const gridCell = getCellAtGlobalPosition(row, col);
                        if (gridCell) {
                            // Im Black-Modus werden aktive Zellen weiß, im Normal-Modus schwarz
                            gridCell.style.backgroundColor = isBlackMode ? '#ffffff' : '#000000';
                        }
                    }
                }
            }
        }
        
        // Video-Display Variablen
        let videoDisplayAnimationId = null;
        let videoThreshold = 127; // Schwellenwert für Schwarz-Weiß (0-255)
        
        // Funktion zum Einrichten der Schwarz-Weiß-Video-Darstellung
        function setupVideoDisplay(video, canvas, ctx) {
            let animationId = null;
            
            function drawFrame() {
                // Prüfe auf nahtlosen Loop: Springe zum Anfang kurz bevor das Video endet
                if (video.duration && video.currentTime >= video.duration - 0.05) {
                    video.currentTime = 0.01; // Nahtloser Übergang zum Anfang
                }
                
                if (video.paused || isFrameNavigationMode) {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                    // Wenn im Frame-Navigationsmodus, zeichne aktuellen Frame
                    if (isFrameNavigationMode && video.paused) {
                        drawCurrentFrame(video, canvas, ctx);
                    }
                    return;
                }
                
                if (video.readyState >= video.HAVE_CURRENT_DATA) {
                    // Setze Canvas-Größe
                    const containerRect = canvas.parentElement.getBoundingClientRect();
                    canvas.width = containerRect.width;
                    canvas.height = containerRect.height;
                    
                    // Zeichne Video-Frame auf temporären Canvas
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = video.videoWidth || canvas.width;
                    tempCanvas.height = video.videoHeight || canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    // Deaktiviere Interpolation beim Zeichnen
                    tempCtx.imageSmoothingEnabled = false;
                    tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Hole Pixel-Daten
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;
                    
                    // Konvertiere zu Schwarz-Weiß mit Schwellenwert
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Berechne Helligkeit (Durchschnitt)
                        const brightness = (r + g + b) / 3;
                        
                        // Wende Schwellenwert an
                        const value = brightness < videoThreshold ? 0 : 255;
                        
                        data[i] = value;     // R
                        data[i + 1] = value; // G
                        data[i + 2] = value; // B
                        // Alpha bleibt unverändert
                    }
                    
                    // Zeichne auf Display-Canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Erstelle neues ImageData für Display-Canvas
                    const displayImageData = ctx.createImageData(canvas.width, canvas.height);
                    const displayData = displayImageData.data;
                    
                    // Berechne Skalierung für object-fit: contain
                    const scale = Math.min(canvas.width / tempCanvas.width, canvas.height / tempCanvas.height);
                    const scaledWidth = tempCanvas.width * scale;
                    const scaledHeight = tempCanvas.height * scale;
                    const offsetX = (canvas.width - scaledWidth) / 2;
                    const offsetY = (canvas.height - scaledHeight) / 2;
                    
                    // Skaliere und zeichne Bilddaten
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const displayIdx = (y * canvas.width + x) * 4;
                            
                            // Prüfe, ob wir innerhalb des skalieren Bereichs sind
                            if (x >= offsetX && x < offsetX + scaledWidth && 
                                y >= offsetY && y < offsetY + scaledHeight) {
                                const sourceX = Math.floor((x - offsetX) / scale);
                                const sourceY = Math.floor((y - offsetY) / scale);
                                const sourceIdx = (sourceY * tempCanvas.width + sourceX) * 4;
                                
                                // Hole Pixel-Wert aus Quelle
                                let pixelValue = data[sourceIdx];
                                
                                // STRENGE Binarisierung: Nur exakt 255 bleibt 255, ALLES andere wird 0
                                // Keine Grauwerte (128, 64, 192, etc.) erlaubt
                                if (pixelValue === 255) {
                                    pixelValue = 255; // Weiß
                                } else {
                                    pixelValue = 0; // Schwarz (auch alle Grauwerte werden schwarz)
                                }
                                
                                displayData[displayIdx] = pixelValue;
                                displayData[displayIdx + 1] = pixelValue;
                                displayData[displayIdx + 2] = pixelValue;
                                displayData[displayIdx + 3] = 255;
                            } else {
                                // Weißer Hintergrund außerhalb
                                displayData[displayIdx] = 255;
                                displayData[displayIdx + 1] = 255;
                                displayData[displayIdx + 2] = 255;
                                displayData[displayIdx + 3] = 255;
                            }
                        }
                    }
                    
                    // Stelle sicher, dass keine Interpolation beim Zeichnen stattfindet
                    ctx.imageSmoothingEnabled = false;
                    ctx.putImageData(displayImageData, 0, 0);
                }
                
                animationId = requestAnimationFrame(drawFrame);
                videoDisplayAnimationId = animationId;
            }
            
            // Starte Animation, wenn Video spielt
            video.addEventListener('play', () => {
                if (!animationId) {
                    drawFrame();
                }
            });
            
            // Stoppe Animation, wenn Video pausiert
            video.addEventListener('pause', () => {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            });
            
            // Starte sofort, wenn Video bereits läuft
            if (!video.paused) {
                drawFrame();
            }
        }
        
        // Funktion zum Einrichten des Play/Pause-Buttons
        function setupVideoPlayPause(video) {
            const playPauseBtn = document.getElementById('videoPlayPauseBtn');
            
            // Play/Pause-Button
            if (playPauseBtn && video) {
                playPauseBtn.addEventListener('click', async () => {
                    if (video.paused) {
                        try {
                            isFrameNavigationMode = false;
                            await video.play();
                            playPauseBtn.textContent = '⏸ Pause';
                        } catch (error) {
                            console.error('Fehler beim Abspielen:', error);
                        }
                    } else {
                        video.pause();
                        isFrameNavigationMode = true;
                        playPauseBtn.textContent = '▶ Play';
                    }
                });
                
                // Update Button-Text basierend auf Video-Status
                video.addEventListener('play', () => {
                    isFrameNavigationMode = false;
                    playPauseBtn.textContent = '⏸ Pause';
                });
                
                video.addEventListener('pause', () => {
                    isFrameNavigationMode = true;
                    playPauseBtn.textContent = '▶ Play';
                });
            }
        }
        
        // Funktion zum Einrichten der Frame-Navigation
        function setupFrameNavigation(video, canvas, ctx) {
            const prevFrameBtn = document.getElementById('prevFrameBtn');
            const nextFrameBtn = document.getElementById('nextFrameBtn');
            
            if (!prevFrameBtn || !nextFrameBtn) return;
            
            // Vorheriger Frame
            prevFrameBtn.addEventListener('click', () => {
                if (currentFrame > 0) {
                    currentFrame--;
                    seekToFrame(video, canvas, ctx, currentFrame);
                }
            });
            
            // Nächster Frame
            nextFrameBtn.addEventListener('click', () => {
                if (currentFrame < totalFrames - 1) {
                    currentFrame++;
                    seekToFrame(video, canvas, ctx, currentFrame);
                }
            });
            
            // Save Frames as PNG Button
            const saveFramesPNGBtn = document.getElementById('saveFramesPNGBtn');
            if (saveFramesPNGBtn) {
                saveFramesPNGBtn.addEventListener('click', () => {
                    saveAllFramesToPNG(video);
                });
            }
            
            // Save Frames as JPEG Button
            const saveFramesJPEGBtn = document.getElementById('saveFramesJPEGBtn');
            if (saveFramesJPEGBtn) {
                saveFramesJPEGBtn.addEventListener('click', () => {
                    saveAllFramesToJPEG(video);
                });
            }
            
            // Black Mode Button
            const blackModeBtn = document.getElementById('blackModeBtn');
            if (blackModeBtn) {
                blackModeBtn.addEventListener('click', () => {
                    toggleBlackMode();
                });
            }
            
            // Update Frame-Info wenn Video gesprungen wird
            video.addEventListener('seeked', () => {
                if (isFrameNavigationMode) {
                    currentFrame = Math.floor(video.currentTime * videoFPS);
                    updateFrameInfo();
                    drawCurrentFrame(video, canvas, ctx);
                }
            });
        }
        
        // Funktion zum Umschalten des Black-Modus
        function toggleBlackMode() {
            isBlackMode = !isBlackMode;
            applyBlackModeColors();
            
            // Aktualisiere Button-Text
            const blackModeBtn = document.getElementById('blackModeBtn');
            if (blackModeBtn) {
                blackModeBtn.textContent = isBlackMode ? 'White' : 'Black';
            }
        }
        
        // Funktion zum Anwenden der Farben basierend auf Modus
        function applyBlackModeColors() {
            // Alle Grid-Container umschalten
            const gridContainers = document.querySelectorAll('.grid-container');
            gridContainers.forEach(container => {
                if (isBlackMode) {
                    container.classList.add('inverted');
                } else {
                    container.classList.remove('inverted');
                }
            });
            
            // Alle Grid-Zellen umschalten: Farben umkehren (weiß wird schwarz, schwarz wird weiß)
            // Methode aus Dance 3.html: Einfache Prüfung ohne 'black' oder 'white' Strings
            const allGridCells = getAllGridCells();
            allGridCells.forEach(cell => {
                const bgColor = window.getComputedStyle(cell).backgroundColor;
                const isBlack = bgColor === 'rgb(0, 0, 0)' || bgColor === '#000000';
                
                if (isBlackMode) {
                    // Im Black-Modus: Farben umkehren (weiß wird schwarz, schwarz wird weiß)
                    if (isBlack) {
                        cell.style.backgroundColor = '#ffffff';
                    } else {
                        cell.style.backgroundColor = '#000000';
                    }
                } else {
                    // Zurück zu Original: Farben wieder umkehren
                    if (isBlack) {
                        cell.style.backgroundColor = '#000000';
                    } else {
                        cell.style.backgroundColor = '#ffffff';
                    }
                }
            });
        }
        
        // Funktion zum Springen zu einem bestimmten Frame
        function seekToFrame(video, canvas, ctx, frameNumber) {
            if (!video || frameNumber < 0 || frameNumber >= totalFrames) return;
            
            // Pausiere Video
            if (!video.paused) {
                video.pause();
            }
            
            isFrameNavigationMode = true;
            currentFrame = frameNumber;
            
            // Berechne Zeit basierend auf Frame-Nummer
            const targetTime = frameNumber / videoFPS;
            video.currentTime = targetTime;
            
            // Warte bis Video gesprungen ist, dann zeichne Frame
            const seekHandler = () => {
                drawCurrentFrame(video, canvas, ctx);
                updateFrameInfo();
                video.removeEventListener('seeked', seekHandler);
            };
            video.addEventListener('seeked', seekHandler);
        }
        
        // Funktion zum Zeichnen des aktuellen Frames
        async function drawCurrentFrame(video, canvas, ctx) {
            if (!video || !canvas || !ctx || video.readyState < video.HAVE_CURRENT_DATA) return;
            
            // Setze Canvas-Größe
            const containerRect = canvas.parentElement.getBoundingClientRect();
            canvas.width = containerRect.width;
            canvas.height = containerRect.height;
            
            // Deaktiviere Canvas-Interpolation, um Grauwerte zu vermeiden
            ctx.imageSmoothingEnabled = false;
            
            // Zeichne Video-Frame auf temporären Canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth || canvas.width;
            tempCanvas.height = video.videoHeight || canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            // Deaktiviere Interpolation beim Zeichnen
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // Erkenne Person mit Pose Detection
            let personMask = null;
            if (poseDetector) {
                try {
                    const pose = await poseDetector.estimateSinglePose(tempCanvas, {
                        flipHorizontal: false,
                        decodingMethod: 'single-person',
                        scoreThreshold: 0.2
                    });
                    
                    if (pose && pose.keypoints && pose.keypoints.length > 0) {
                        // Erstelle Maske für die Person
                        personMask = createPersonMask(pose.keypoints, tempCanvas.width, tempCanvas.height);
                    }
                } catch (error) {
                    console.error('Fehler bei Person-Erkennung:', error);
                }
            }
            
            // Hole Pixel-Daten
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Konvertiere zu Schwarz-Weiß mit Schwellenwert und Keying
            for (let i = 0; i < data.length; i += 4) {
                const x = (i / 4) % tempCanvas.width;
                const y = Math.floor((i / 4) / tempCanvas.width);
                
                // Prüfe, ob Pixel zur Person gehört
                const isPersonPixel = personMask && personMask[y * tempCanvas.width + x];
                
                if (isPersonPixel) {
                    // Pixel gehört zur Person: Wende Schwellenwert an
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Berechne Helligkeit (Durchschnitt)
                    const brightness = (r + g + b) / 3;
                    
                    // Wende Schwellenwert an
                    const value = brightness < videoThreshold ? 0 : 255;
                    
                    data[i] = value;     // R
                    data[i + 1] = value; // G
                    data[i + 2] = value; // B
                } else {
                    // Pixel gehört nicht zur Person: Mache Hintergrund weiß
                    data[i] = 255;     // R
                    data[i + 1] = 255; // G
                    data[i + 2] = 255; // B
                }
            }
            
            // Zeichne auf Display-Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Erstelle neues ImageData für Display-Canvas
            const displayImageData = ctx.createImageData(canvas.width, canvas.height);
            const displayData = displayImageData.data;
            
            // Berechne Skalierung für object-fit: contain
            const scale = Math.min(canvas.width / tempCanvas.width, canvas.height / tempCanvas.height);
            const scaledWidth = tempCanvas.width * scale;
            const scaledHeight = tempCanvas.height * scale;
            const offsetX = (canvas.width - scaledWidth) / 2;
            const offsetY = (canvas.height - scaledHeight) / 2;
            
            // Skaliere und zeichne Bilddaten
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const displayIdx = (y * canvas.width + x) * 4;
                    
                    // Prüfe, ob wir innerhalb des skalieren Bereichs sind
                    if (x >= offsetX && x < offsetX + scaledWidth && 
                        y >= offsetY && y < offsetY + scaledHeight) {
                        const sourceX = Math.floor((x - offsetX) / scale);
                        const sourceY = Math.floor((y - offsetY) / scale);
                        const sourceIdx = (sourceY * tempCanvas.width + sourceX) * 4;
                        
                        // Hole Pixel-Wert aus Quelle
                        let pixelValue = data[sourceIdx];
                        
                        // STRENGE Binarisierung: Nur exakt 255 bleibt 255, ALLES andere wird 0
                        // Keine Grauwerte (128, 64, 192, etc.) erlaubt
                        if (pixelValue === 255) {
                            pixelValue = 255; // Weiß
                        } else {
                            pixelValue = 0; // Schwarz (auch alle Grauwerte werden schwarz)
                        }
                        
                        displayData[displayIdx] = pixelValue;
                        displayData[displayIdx + 1] = pixelValue;
                        displayData[displayIdx + 2] = pixelValue;
                        displayData[displayIdx + 3] = 255;
                    } else {
                        // Weißer Hintergrund außerhalb
                        displayData[displayIdx] = 255;
                        displayData[displayIdx + 1] = 255;
                        displayData[displayIdx + 2] = 255;
                        displayData[displayIdx + 3] = 255;
                    }
                }
            }
            
            // Stelle sicher, dass keine Interpolation beim Zeichnen stattfindet
            ctx.imageSmoothingEnabled = false;
            ctx.putImageData(displayImageData, 0, 0);
        }
        
        // Funktion zum Aktualisieren der Frame-Info-Anzeige
        function updateFrameInfo() {
            const frameInfo = document.getElementById('frameInfo');
            if (frameInfo) {
                frameInfo.textContent = `Frame: ${currentFrame + 1} / ${totalFrames}`;
            }
        }
        
        // Funktion zum Zeichnen des aktuellen Grid-Zustands auf Canvas
        function drawGridStateToCanvas(canvas, ctx) {
            // Berechne Gitter-Größe basierend auf tatsächlicher Bildschirmgröße
            // Hole die tatsächliche Breite des ersten Grid-Containers
            const firstGrid = document.querySelector('.grid-container');
            if (!firstGrid) {
                // Fallback-Werte
                const totalWidth = 800;
                const gap = 1;
                const padding = 1;
                const border = 1;
                const cellWidth = (totalWidth - (columns + 1) * gap - 2 * padding - 2 * border) / columns;
                const cellHeight = cellWidth / 2;
                canvas.width = totalWidth;
                canvas.height = 400;
                return;
            }
            
            const gridRect = firstGrid.getBoundingClientRect();
            const totalWidth = gridRect.width;
            const gap = 1; // Wie auf der Website: gap: 1px
            const padding = 1; // Wie auf der Website: padding: 1px
            const border = 1; // Wie auf der Website: border: 1px
            const gridSpacing = 10;
            // Berechne Zellbreite basierend auf tatsächlicher Grid-Breite
            const cellWidth = (totalWidth - (columns + 1) * gap - 2 * padding - 2 * border) / columns;
            const cellHeight = cellWidth / 2; // Verhältnis 2:1 (Breite:Höhe)
            
            // Berechne Gesamtbreite (alle Grids haben die gleiche Breite)
            const gridWidth = totalWidth;
            
            // Berechne Gesamthöhe (alle Grids + Abstände)
            let totalHeight = 0;
            gridContainers.forEach((gridContainer, gridIndex) => {
                const rowsInThisGrid = (gridIndex === numGrids - 1) ? (totalRows - gridIndex * rowsPerGrid) : rowsPerGrid;
                const gridHeight = rowsInThisGrid * cellHeight + (rowsInThisGrid + 1) * gap + 2 * padding + 2 * border;
                totalHeight += gridHeight;
                if (gridIndex < numGrids - 1) {
                    totalHeight += gridSpacing; // Abstand zwischen Grids (außer nach dem letzten)
                }
            });
            
            // Setze Canvas-Größe basierend auf berechneten Werten
            canvas.width = gridWidth;
            canvas.height = totalHeight;
            
            // Hintergrund transparent (nicht weiß)
            // Canvas ist standardmäßig transparent, daher nichts zeichnen
            
            // Zeichne alle Grid-Container
            let currentY = 0;
            const allGridCells = getAllGridCells();
            
            gridContainers.forEach((gridContainer, gridIndex) => {
                const rowsInThisGrid = (gridIndex === numGrids - 1) ? (totalRows - gridIndex * rowsPerGrid) : rowsPerGrid;
                const gridHeight = rowsInThisGrid * cellHeight + (rowsInThisGrid + 1) * gap + 2 * padding + 2 * border;
                
                // Zeichne schwarzen Hintergrund für Grid-Container (wie auf der Website: background-color: #000000)
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, currentY, gridWidth, gridHeight);
                
                // Zeichne Zellen dieses Grids
                // Die gap-Linien entstehen automatisch durch den schwarzen Hintergrund zwischen den Zellen
                // Positionierung: padding am Rand, dann gap, dann Zelle, dann gap, etc.
                // Dies stellt sicher, dass alle gap-Linien gleich dick sind (gap px = 1px)
                for (let row = 0; row < rowsInThisGrid; row++) {
                    for (let col = 0; col < columns; col++) {
                        const globalRow = gridIndex * rowsPerGrid + row;
                        const cell = getCellAtGlobalPosition(globalRow, col);
                        if (!cell) continue;
                        
                        const bgColor = window.getComputedStyle(cell).backgroundColor;
                        // Position: border + padding + col * (cellWidth + gap)
                        // Dies stellt sicher, dass alle gap-Linien gleich dick sind (gap px)
                        const x = border + padding + col * (cellWidth + gap);
                        const y = currentY + border + padding + row * (cellHeight + gap);
                
                        // Zellenfarbe - zeichne sowohl schwarze als auch weiße Kästen
                        // Methode aus Dance 3.html: Einfache Prüfung, keine Grauwerte
                        if (bgColor === 'rgb(0, 0, 0)' || bgColor === '#000000') {
                            // Schwarze Zelle: zeichne schwarz (fügt sich nahtlos in schwarzen Hintergrund ein)
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(x, y, cellWidth, cellHeight);
                        } else {
                            // Weiße Zelle: zeichne weiß
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(x, y, cellWidth, cellHeight);
                        }
                    }
                }
                
                // Zeichne schwarzen Border um das Grid (gleich dick wie auf der Website)
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = border; // border = 1px, gleich wie auf der Website
                ctx.strokeRect(0, currentY, gridWidth, gridHeight);
                
                currentY += gridHeight;
                if (gridIndex < numGrids - 1) {
                    currentY += gridSpacing; // Abstand zwischen Grids
                }
            });
        }
        
        // Funktion zum Speichern aller Frames als DIN A4 PNG mit transparentem Hintergrund
        async function saveAllFramesToPNG(video) {
            if (!video || !videoElement || totalFrames === 0) {
                alert('Please load a video first!');
                return;
            }
            
            const saveFramesPNGBtn = document.getElementById('saveFramesPNGBtn');
            if (saveFramesPNGBtn) {
                saveFramesPNGBtn.disabled = true;
                saveFramesPNGBtn.textContent = 'Saving...';
            }
            
            // Pausiere Video
            const wasPlaying = !video.paused;
            if (wasPlaying) {
                video.pause();
            }
            
            // Erstelle temporären Canvas für Grid-Zeichnung
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Zeichne ersten Frame, um Gitter-Größe zu bestimmen
            const originalTime = video.currentTime;
            const originalFrame = currentFrame;
            isFrameNavigationMode = true;
            
            // Springe zum ersten Frame, um Größe zu bestimmen
            video.currentTime = 0;
            await new Promise((resolve) => {
                const seekHandler = () => {
                    video.removeEventListener('seeked', seekHandler);
                    resolve();
                };
                video.addEventListener('seeked', seekHandler);
                setTimeout(() => {
                    video.removeEventListener('seeked', seekHandler);
                    resolve();
                }, 500);
            });
            
            if (poseDetector && videoElement && videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
                await drawStickman();
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            drawGridStateToCanvas(tempCanvas, tempCtx);
            
            // DIN A4 Format: 210mm x 297mm
            // Bei 300 DPI: 2480 x 3508 Pixel (hohe Qualität)
            const dpi = 300;
            const mmToInch = 0.0393701;
            const a4WidthMm = 210;
            const a4HeightMm = 297;
            const a4WidthPx = Math.round(a4WidthMm * mmToInch * dpi);
            const a4HeightPx = Math.round(a4HeightMm * mmToInch * dpi);
            
            const margin = 20; // Rand in Pixel
            const gridsPerRow = 4; // 4 Gitter pro Reihe (Spalten)
            const rowsPerPage = 6; // 6 Reihen pro Seite
            const gridsPerPage = gridsPerRow * rowsPerPage; // 24 Gitter pro Seite
            
            // Berechne verfügbaren Platz für Gitter (ohne Ränder)
            const availableWidth = a4WidthPx - (margin * 2);
            const availableHeight = a4HeightPx - (margin * 2);
            
            // Berechne Größe jedes einzelnen Gitters
            const gridWidthPx = tempCanvas.width;
            const gridHeightPx = tempCanvas.height;
            
            // Berechne Skalierung, damit 6x4 Gitter auf die Seite passen (6 Reihen x 4 Spalten)
            const scaleX = (availableWidth / gridsPerRow) / gridWidthPx;
            const scaleY = (availableHeight / rowsPerPage) / gridHeightPx;
            const scale = Math.min(scaleX, scaleY); // Verwende kleinere Skalierung
            
            // Finale Gitter-Größe in Pixel
            const scaledGridWidth = Math.round(gridWidthPx * scale);
            const scaledGridHeight = Math.round(gridHeightPx * scale);
            
            // Berechne Abstand zwischen Gittern (Abstand bleibt wie gehabt)
            const spacingX = Math.round((availableWidth - (scaledGridWidth * gridsPerRow)) / (gridsPerRow - 1));
            const spacingY = Math.round((availableHeight - (scaledGridHeight * rowsPerPage)) / (rowsPerPage - 1));
            
            // Berechne Gesamtgröße der Gittergruppe (für Zentrierung)
            const totalGroupWidth = gridsPerRow * scaledGridWidth + (gridsPerRow - 1) * spacingX;
            const totalGroupHeight = rowsPerPage * scaledGridHeight + (rowsPerPage - 1) * spacingY;
            
            // Berechne Startposition für Zentrierung
            const startX = Math.round((a4WidthPx - totalGroupWidth) / 2);
            const startY = Math.round((a4HeightPx - totalGroupHeight) / 2);
            
            try {
                // Berechne verfügbare Frames (jeder 3. Frame)
                const availableFrames = [];
                for (let frame = 0; frame < totalFrames; frame += 3) {
                    availableFrames.push(frame);
                }
                
                // Immer genau 24 Gitter: Wenn weniger als 24 Frames, wiederhole chronologisch von vorne
                // Wenn mehr als 24 Frames, verwende nur die ersten 24
                const framesToUse = [];
                if (availableFrames.length < gridsPerPage) {
                    // Wiederhole Frames, bis es genau 24 sind
                    while (framesToUse.length < gridsPerPage) {
                        for (let i = 0; i < availableFrames.length && framesToUse.length < gridsPerPage; i++) {
                            framesToUse.push(availableFrames[i]);
                        }
                    }
                } else {
                    // Verwende nur die ersten 24 Frames
                    framesToUse.push(...availableFrames.slice(0, gridsPerPage));
                }
                
                let savedFrameCount = 0;
                
                // Erstelle DIN A4 Canvas für die Seite
                const pageCanvas = document.createElement('canvas');
                pageCanvas.width = a4WidthPx;
                pageCanvas.height = a4HeightPx;
                const pageCtx = pageCanvas.getContext('2d');
                
                // Hintergrund transparent (nicht weiß)
                // Canvas ist standardmäßig transparent, daher nichts zeichnen
                
                // Gehe durch alle Frames (immer genau 24, bei weniger werden sie wiederholt, bei mehr nur die ersten 24)
                for (let i = 0; i < framesToUse.length; i++) {
                    const frame = framesToUse[i];
                    
                    // Springe zum Frame
                    const targetTime = frame / videoFPS;
                    video.currentTime = targetTime;
                    
                    // Warte bis Video gesprungen ist
                    await new Promise((resolve) => {
                        const seekHandler = () => {
                            video.removeEventListener('seeked', seekHandler);
                            resolve();
                        };
                        video.addEventListener('seeked', seekHandler);
                        
                        // Timeout als Fallback
                        setTimeout(() => {
                            video.removeEventListener('seeked', seekHandler);
                            resolve();
                        }, 500);
                    });
                    
                    // Aktualisiere aktuellen Frame
                    currentFrame = frame;
                    updateFrameInfo();
                    
                    // Stoppe Animation-Loop, damit nur dieser Frame gezeichnet wird
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    
                    // Führe Pose Detection für diesen Frame aus
                    if (poseDetector && videoElement && videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
                        await drawStickman();
                        // Warte länger, damit die Analyse vollständig abgeschlossen ist und transferStickmanToGrid aufgerufen wurde
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                        // Warte kurz, falls keine Pose Detection
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    // Zeichne aktuellen Grid-Zustand (nur die Kästen, die aktuell eingefärbt sind)
                    drawGridStateToCanvas(tempCanvas, tempCtx);
                    
                    // Berechne Position des Gitters auf der Seite
                    const gridIndex = i;
                    const row = Math.floor(gridIndex / gridsPerRow);
                    const col = gridIndex % gridsPerRow;
                    
                    const x = startX + col * (scaledGridWidth + spacingX);
                    const y = startY + row * (scaledGridHeight + spacingY);
                    
                    // Zeichne Grid auf die Seite (mit hoher Qualität)
                    pageCtx.imageSmoothingEnabled = true;
                    pageCtx.imageSmoothingQuality = 'high';
                    pageCtx.drawImage(tempCanvas, x, y, scaledGridWidth, scaledGridHeight);
                    
                    savedFrameCount++;
                    
                    // Update Status
                    if (saveFramesPNGBtn) {
                        saveFramesPNGBtn.textContent = `Saving... ${savedFrameCount}/${framesToUse.length}`;
                    }
                }
                
                // Speichere PNG (immer nur eine Seite mit 24 Gittern, mit transparentem Hintergrund)
                const pageDataUrl = pageCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `video-frames-${Date.now()}.png`;
                link.href = pageDataUrl;
                link.click();
                
                // Wiederherstellen des ursprünglichen Zustands
                video.currentTime = originalTime;
                currentFrame = originalFrame;
                
                // Warte bis Video gesprungen ist
                await new Promise((resolve) => {
                    const seekHandler = () => {
                        video.removeEventListener('seeked', seekHandler);
                        resolve();
                    };
                    video.addEventListener('seeked', seekHandler);
                    setTimeout(() => {
                        video.removeEventListener('seeked', seekHandler);
                        resolve();
                    }, 500);
                });
                
                // Aktualisiere Display
                const videoCanvas = document.querySelector('.video-item canvas');
                if (videoCanvas) {
                    const videoCtx = videoCanvas.getContext('2d');
                    drawCurrentFrame(video, videoCanvas, videoCtx);
                    updateFrameInfo();
                }
                
                if (wasPlaying) {
                    video.play();
                }
                
                isFrameNavigationMode = false;
                
                alert(`Successfully saved ${savedFrameCount} frames as PNG!`);
                
            } catch (error) {
                console.error('Error saving frames as PNG:', error);
                alert('Error saving frames as PNG: ' + error.message);
            } finally {
                if (saveFramesPNGBtn) {
                    saveFramesPNGBtn.disabled = false;
                    saveFramesPNGBtn.textContent = 'Save as PNG';
                }
            }
        }
        
        // Funktion zum Speichern aller Frames als einzelne JPEGs (7x7 Zoll, Gitter mittig)
        async function saveAllFramesToJPEG(video) {
            if (!video || !videoElement || totalFrames === 0) {
                alert('Please load a video first!');
                return;
            }
            
            const saveFramesJPEGBtn = document.getElementById('saveFramesJPEGBtn');
            if (saveFramesJPEGBtn) {
                saveFramesJPEGBtn.disabled = true;
                saveFramesJPEGBtn.textContent = 'Saving...';
            }
            
            // Pausiere Video
            const wasPlaying = !video.paused;
            if (wasPlaying) {
                video.pause();
            }
            
            // Erstelle temporären Canvas für Grid-Zeichnung
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Zeichne ersten Frame, um Gitter-Größe zu bestimmen
            const originalTime = video.currentTime;
            const originalFrame = currentFrame;
            isFrameNavigationMode = true;
            
            // Springe zum ersten Frame, um Größe zu bestimmen
            video.currentTime = 0;
            await new Promise((resolve) => {
                const seekHandler = () => {
                    video.removeEventListener('seeked', seekHandler);
                    resolve();
                };
                video.addEventListener('seeked', seekHandler);
                setTimeout(() => {
                    video.removeEventListener('seeked', seekHandler);
                    resolve();
                }, 500);
            });
            
            if (poseDetector && videoElement && videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
                await drawStickman();
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            drawGridStateToCanvas(tempCanvas, tempCtx);
            
            // 7x7 Zoll Format bei 300 DPI: 2100 x 2100 Pixel
            const dpi = 300;
            const mmToInch = 0.0393701;
            const sizeInch = 7;
            const sizePx = Math.round(sizeInch * dpi); // 2100 Pixel
            
            // Immer genau 50 Frames speichern
            const targetFrameCount = 50;
            const framesToUse = [];
            
            if (totalFrames >= targetFrameCount) {
                // Wenn mehr oder gleich viele Frames vorhanden sind, überspringe gleichmäßig
                const step = totalFrames / targetFrameCount;
                for (let i = 0; i < targetFrameCount; i++) {
                    const frameIndex = Math.floor(i * step);
                    framesToUse.push(frameIndex);
                }
            } else {
                // Wenn weniger Frames vorhanden sind, wiederhole Frames
                while (framesToUse.length < targetFrameCount) {
                    for (let frame = 0; frame < totalFrames && framesToUse.length < targetFrameCount; frame++) {
                        framesToUse.push(frame);
                    }
                }
            }
            
            let savedFrameCount = 0;
            let folderHandle = null;
            
            try {
                // Erstelle oder wähle Ordner für JPEGs
                if ('showDirectoryPicker' in window) {
                    try {
                        // Versuche Ordner zu wählen oder zu erstellen
                        folderHandle = await window.showDirectoryPicker();
                        
                        // Versuche "Dance pixel frames" Ordner zu finden oder erstelle ihn
                        try {
                            folderHandle = await folderHandle.getDirectoryHandle('Dance pixel frames', { create: true });
                        } catch (error) {
                            // Wenn der ausgewählte Ordner selbst "Dance pixel frames" heißt
                            if (folderHandle.name === 'Dance pixel frames') {
                                // Verwende diesen Ordner
                            } else {
                                // Versuche "Dance pixel frames" als Unterordner zu erstellen
                                folderHandle = await folderHandle.getDirectoryHandle('Dance pixel frames', { create: true });
                            }
                        }
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            console.error('Fehler bei Ordner-Auswahl:', error);
                            alert('Could not select folder. Frames will be downloaded individually.');
                        } else {
                            // Benutzer hat abgebrochen
                            if (saveFramesJPEGBtn) {
                                saveFramesJPEGBtn.disabled = false;
                                saveFramesJPEGBtn.textContent = 'Save Frames as JPEG';
                            }
                            return;
                        }
                    }
                }
                
                // Gehe durch alle 50 Frames
                for (let i = 0; i < framesToUse.length; i++) {
                    const frame = framesToUse[i];
                    
                    // Springe zum Frame
                    const targetTime = frame / videoFPS;
                    video.currentTime = targetTime;
                    
                    // Warte bis Video gesprungen ist
                    await new Promise((resolve) => {
                        const seekHandler = () => {
                            video.removeEventListener('seeked', seekHandler);
                            resolve();
                        };
                        video.addEventListener('seeked', seekHandler);
                        
                        // Timeout als Fallback
                        setTimeout(() => {
                            video.removeEventListener('seeked', seekHandler);
                            resolve();
                        }, 500);
                    });
                    
                    // Aktualisiere aktuellen Frame
                    currentFrame = frame;
                    updateFrameInfo();
                    
                    // Stoppe Animation-Loop, damit nur dieser Frame gezeichnet wird
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    
                    // Führe Pose Detection für diesen Frame aus
                    if (poseDetector && videoElement && videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
                        await drawStickman();
                        // Warte länger, damit die Analyse vollständig abgeschlossen ist
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } else {
                        // Warte kurz, falls keine Pose Detection
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    // Zeichne aktuellen Grid-Zustand
                    drawGridStateToCanvas(tempCanvas, tempCtx);
                    
                    // Erstelle 7x7 Zoll Canvas
                    const frameCanvas = document.createElement('canvas');
                    frameCanvas.width = sizePx;
                    frameCanvas.height = sizePx;
                    const frameCtx = frameCanvas.getContext('2d');
                    
                    // Weißer Hintergrund für JPEG (JPEG unterstützt kein Transparenz)
                    frameCtx.fillStyle = '#ffffff';
                    frameCtx.fillRect(0, 0, sizePx, sizePx);
                    
                    // Berechne Skalierung, damit das Gitter mittig passt
                    const gridWidth = tempCanvas.width;
                    const gridHeight = tempCanvas.height;
                    
                    // Berechne Skalierung, damit das Gitter in den 7x7 Zoll Bereich passt (mit etwas Rand)
                    const margin = sizePx * 0.1; // 10% Rand
                    const availableSize = sizePx - (margin * 2);
                    const scaleX = availableSize / gridWidth;
                    const scaleY = availableSize / gridHeight;
                    const scale = Math.min(scaleX, scaleY); // Verwende kleinere Skalierung
                    
                    // Finale Gitter-Größe
                    const scaledGridWidth = gridWidth * scale;
                    const scaledGridHeight = gridHeight * scale;
                    
                    // Berechne Position für Zentrierung
                    const x = (sizePx - scaledGridWidth) / 2;
                    const y = (sizePx - scaledGridHeight) / 2;
                    
                    // Zeichne Grid mittig auf Canvas (mit hoher Qualität, keine Glättung für scharfe Linien)
                    frameCtx.imageSmoothingEnabled = false; // Keine Glättung für scharfe Gitterlinien
                    frameCtx.drawImage(tempCanvas, x, y, scaledGridWidth, scaledGridHeight);
                    
                    // Konvertiere zu JPEG Blob mit höherer Qualität
                    const dataUrl = frameCanvas.toDataURL('image/jpeg', 0.98);
                    const blob = await fetch(dataUrl).then(res => res.blob());
                    
                    // Speichere JPEG (nummeriere von 0-49)
                    const fileName = `frame-${String(i).padStart(2, '0')}.jpg`;
                    
                    if (folderHandle) {
                        // Speichere im Ordner
                        try {
                            const fileHandle = await folderHandle.getFileHandle(fileName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();
                        } catch (error) {
                            console.error(`Error saving ${fileName}:`, error);
                        }
                    } else {
                        // Fallback: Download einzeln
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    }
                    
                    savedFrameCount++;
                    
                    // Update Status
                    if (saveFramesJPEGBtn) {
                        saveFramesJPEGBtn.textContent = `Saving... ${savedFrameCount}/${targetFrameCount}`;
                    }
                }
                
                // Wiederherstellen des ursprünglichen Zustands
                video.currentTime = originalTime;
                currentFrame = originalFrame;
                
                // Warte bis Video gesprungen ist
                await new Promise((resolve) => {
                    const seekHandler = () => {
                        video.removeEventListener('seeked', seekHandler);
                        resolve();
                    };
                    video.addEventListener('seeked', seekHandler);
                    setTimeout(() => {
                        video.removeEventListener('seeked', seekHandler);
                        resolve();
                    }, 500);
                });
                
                // Aktualisiere Display
                const videoCanvas = document.querySelector('.video-item canvas');
                if (videoCanvas) {
                    const videoCtx = videoCanvas.getContext('2d');
                    drawCurrentFrame(video, videoCanvas, videoCtx);
                    updateFrameInfo();
                }
                
                if (wasPlaying) {
                    video.play();
                }
                
                isFrameNavigationMode = false;
                
                if (folderHandle) {
                    alert(`Successfully saved ${savedFrameCount} frames as JPEG in "Dance pixel frames" folder!`);
                } else {
                    alert(`Successfully saved ${savedFrameCount} frames as JPEG!`);
                }
                
            } catch (error) {
                console.error('Error saving frames as JPEG:', error);
                alert('Error saving frames as JPEG: ' + error.message);
            } finally {
                if (saveFramesJPEGBtn) {
                    saveFramesJPEGBtn.disabled = false;
                    saveFramesJPEGBtn.textContent = 'Save Frames as JPEG';
                }
            }
        }
        
        // Grid-Recording Variablen
        let gridRecordingStream = null;
        let gridMediaRecorder = null;
        let gridRecordingChunks = [];
        let gridRecordingCanvas = null;
        let gridRecordingCtx = null;
        let gridRecordingAnimationId = null;
        let gridRecordingStartTime = null;
        let gridRecordingDuration = 0;
        let selectedFolderHandle = null;
        
        // Funktion zum Aufnehmen des Grid-Videos
        async function startGridRecording() {
            const durationInput = document.getElementById('recordingDuration');
            const startBtn = document.getElementById('startRecordingBtn');
            const stopBtn = document.getElementById('stopRecordingBtn');
            const statusDiv = document.getElementById('recordingStatus');
            
            if (!durationInput || !startBtn || !stopBtn || !statusDiv) return;
            
            gridRecordingDuration = parseInt(durationInput.value) || 5;
            
            if (gridRecordingDuration < 1 || gridRecordingDuration > 60) {
                alert('Duration must be between 1 and 60 seconds!');
                return;
            }
            
            // Prüfe, ob Ordner ausgewählt wurde
            if (!selectedFolderHandle && 'showDirectoryPicker' in window) {
                statusDiv.textContent = 'Please select a folder first!';
                // Versuche automatisch Ordner auszuwählen
                await selectFolder();
                if (!selectedFolderHandle) {
                    alert('Please select a folder before starting the recording.');
                    return;
                }
            }
            
            // Erstelle Canvas für Recording
            const gridWrapperRect = gridWrapper.getBoundingClientRect();
            gridRecordingCanvas = document.createElement('canvas');
            gridRecordingCanvas.width = gridWrapperRect.width;
            gridRecordingCanvas.height = gridWrapperRect.height;
            gridRecordingCtx = gridRecordingCanvas.getContext('2d');
            
            // Erstelle Stream vom Canvas
            gridRecordingStream = gridRecordingCanvas.captureStream(30); // 30 FPS
            
            // Initialisiere MediaRecorder mit MP4-Unterstützung
            const codecs = [
                'video/mp4;codecs=h264,aac',
                'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
                'video/mp4',
                'video/webm;codecs=vp9,opus',
                'video/webm;codecs=vp8,opus',
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm'
            ];

            let selectedMimeType = 'video/webm';
            let fileExtension = 'webm';
            for (const codec of codecs) {
                if (MediaRecorder.isTypeSupported(codec)) {
                    selectedMimeType = codec;
                    if (codec.includes('mp4')) {
                        fileExtension = 'mp4';
                    }
                    break;
                }
            }

            const options = {
                mimeType: selectedMimeType,
                videoBitsPerSecond: 5000000 // Higher bitrate for better quality
            };
            
            try {
                gridMediaRecorder = new MediaRecorder(gridRecordingStream, options);
            } catch (e) {
                // Fallback
                gridMediaRecorder = new MediaRecorder(gridRecordingStream);
            }
            
            gridRecordingChunks = [];
            const finalFileExtension = fileExtension; // Store for use in onstop
            
            gridMediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    gridRecordingChunks.push(event.data);
                }
            };
            
            gridMediaRecorder.onstop = async () => {
                const blob = new Blob(gridRecordingChunks, { type: selectedMimeType });
                
                try {
                    // Versuche im ausgewählten Ordner zu speichern
                    if (selectedFolderHandle) {
                        const fileName = `grid-recording-${Date.now()}.${finalFileExtension}`;
                        const fileHandle = await selectedFolderHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        statusDiv.textContent = `Video saved in "Dance pixel"! (${fileName})`;
                    } else if ('showDirectoryPicker' in window) {
                        // Wenn kein Ordner ausgewählt, versuche File System Access API
                        statusDiv.textContent = 'Please select a folder first!';
                    } else {
                        // Fallback: Standard-Download
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `grid-recording-${Date.now()}.${finalFileExtension}`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        statusDiv.textContent = 'Video is being downloaded!';
                    }
                } catch (error) {
                    console.error('Fehler beim Speichern:', error);
                    // Fallback: Standard-Download
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `grid-recording-${Date.now()}.${finalFileExtension}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    statusDiv.textContent = 'Video is being downloaded!';
                }
                
                setTimeout(() => {
                    statusDiv.textContent = '';
                }, 5000);
            };
            
            // Starte Recording
            gridMediaRecorder.start();
            gridRecordingStartTime = Date.now();
            
            // UI aktualisieren
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            statusDiv.textContent = `Recording... (0/${gridRecordingDuration}s)`;
            
            // Starte Animation-Loop
            function recordFrame() {
                const elapsed = (Date.now() - gridRecordingStartTime) / 1000;
                
                if (elapsed >= gridRecordingDuration) {
                    stopGridRecording();
                    return;
                }
                
                // Zeichne Grid auf Canvas
                drawGridToCanvas();
                
                // Update Status
                statusDiv.textContent = `Recording... (${Math.floor(elapsed)}/${gridRecordingDuration}s)`;
                
                gridRecordingAnimationId = requestAnimationFrame(recordFrame);
            }
            
            recordFrame();
        }
        
        // Funktion zum Zeichnen des Grids auf Canvas
        function drawGridToCanvas() {
            if (!gridRecordingCanvas || !gridRecordingCtx) return;
            
            const gridWrapperRect = gridWrapper.getBoundingClientRect();
            
            // Aktualisiere Canvas-Größe wenn nötig
            if (gridRecordingCanvas.width !== gridWrapperRect.width || gridRecordingCanvas.height !== gridWrapperRect.height) {
                gridRecordingCanvas.width = gridWrapperRect.width;
                gridRecordingCanvas.height = gridWrapperRect.height;
            }
            
            // Hintergrund basierend auf Modus
            gridRecordingCtx.fillStyle = isBlackMode ? '#000000' : '#ffffff';
            gridRecordingCtx.fillRect(0, 0, gridRecordingCanvas.width, gridRecordingCanvas.height);
            
            // Zeichne alle Grid-Container
            let currentY = 0;
            const allGridCells = getAllGridCells();
            // Berechne Zellgröße basierend auf 650px Gesamtbreite
            const totalWidth = 650;
            const gap = 1;
            const border = 1;
            const cellWidth = (totalWidth - (columns + 1) * gap - 2 * border) / columns; // ≈ 39.44px
            const cellHeight = cellWidth / 2; // Verhältnis 2:1 ≈ 19.72px
            
            gridContainers.forEach((gridContainer, gridIndex) => {
                const rowsInThisGrid = (gridIndex === numGrids - 1) ? (totalRows - gridIndex * rowsPerGrid) : rowsPerGrid;
                const gridWidth = columns * cellWidth + (columns + 1) * gap + border * 2;
                const gridHeight = rowsInThisGrid * cellHeight + (rowsInThisGrid + 1) * gap + border * 2;
                
                // Hintergrund für Gitterlinien basierend auf Modus (weiß im Black-Modus, schwarz im Normal-Modus)
                gridRecordingCtx.fillStyle = isBlackMode ? '#ffffff' : '#000000';
                gridRecordingCtx.fillRect(0, currentY, gridWidth, gridHeight);
                
                // Zeichne Zellen dieses Grids
                for (let row = 0; row < rowsInThisGrid; row++) {
                    for (let col = 0; col < columns; col++) {
                        const globalRow = gridIndex * rowsPerGrid + row;
                        const cell = getCellAtGlobalPosition(globalRow, col);
                        if (!cell) continue;
                        
                const bgColor = window.getComputedStyle(cell).backgroundColor;
                        const x = border + gap + col * (cellWidth + gap);
                        const y = currentY + border + gap + row * (cellHeight + gap);
                
                        // Zellenfarbe - nur vollständig schwarze oder weiße Zellen, keine grauen/transparenten Zwischenzustände
                        // Konvertiere RGB-String zu RGB-Werten für präzise Prüfung
                        let r = 255, g = 255, b = 255;
                        if (bgColor.startsWith('rgb')) {
                            const matches = bgColor.match(/\d+/g);
                            if (matches && matches.length >= 3) {
                                r = parseInt(matches[0]);
                                g = parseInt(matches[1]);
                                b = parseInt(matches[2]);
                            }
                        } else if (bgColor === '#000000' || bgColor === 'black') {
                            r = 0; g = 0; b = 0;
                        } else if (bgColor === '#ffffff' || bgColor === 'white') {
                            r = 255; g = 255; b = 255;
                        }
                        
                        // Nur vollständig schwarze (0,0,0) oder weiße (255,255,255) Zellen werden aufgezeichnet
                        // Alle anderen (grau, transparent, etc.) werden als weiß behandelt
                        const isPureBlack = r === 0 && g === 0 && b === 0;
                        const isPureWhite = r === 255 && g === 255 && b === 255;
                        
                        if (isPureBlack) {
                    gridRecordingCtx.fillStyle = '#000000';
                } else {
                            // Alle anderen (weiß, grau, transparent) werden weiß
                    gridRecordingCtx.fillStyle = '#ffffff';
                }
                gridRecordingCtx.fillRect(x, y, cellWidth, cellHeight);
                    }
                }
                
                currentY += gridHeight + 10; // 10px Abstand zwischen Grids
            });
        }
        
        // Funktion zum Stoppen der Aufnahme
        function stopGridRecording() {
            if (gridMediaRecorder && gridMediaRecorder.state !== 'inactive') {
                gridMediaRecorder.stop();
            }
            
            if (gridRecordingAnimationId) {
                cancelAnimationFrame(gridRecordingAnimationId);
                gridRecordingAnimationId = null;
            }
            
            if (gridRecordingStream) {
                gridRecordingStream.getTracks().forEach(track => track.stop());
                gridRecordingStream = null;
            }
            
            const startBtn = document.getElementById('startRecordingBtn');
            const stopBtn = document.getElementById('stopRecordingBtn');
            const statusDiv = document.getElementById('recordingStatus');
            
            if (startBtn) startBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (statusDiv) statusDiv.textContent = 'Processing recording...';
        }
        
        // Funktion zum Auswählen des Ordners "Tanz pixel"
        async function selectFolder() {
            const folderStatus = document.getElementById('folderStatus');
            
            try {
                if ('showDirectoryPicker' in window) {
                    // Öffne Ordner-Picker
                    const handle = await window.showDirectoryPicker();
                    
                    // Versuche "Tanz pixel" Ordner zu finden oder erstelle ihn
                    try {
                        // Versuche "Tanz pixel" Ordner zu finden oder erstelle ihn
                        const tanzPixelFolder = await handle.getDirectoryHandle('Dance pixel', { create: true });
                        selectedFolderHandle = tanzPixelFolder;
                        
                        if (folderStatus) {
                            folderStatus.textContent = '✓ Folder: Dance pixel';
                            folderStatus.style.color = '#000000';
                        }
                    } catch (error) {
                        // Wenn "Tanz pixel" nicht erstellt werden kann, prüfe ob der Ordner selbst "Tanz pixel" heißt
                        if (handle.name === 'Dance pixel') {
                            selectedFolderHandle = handle;
                            if (folderStatus) {
                                folderStatus.textContent = '✓ Folder: Dance pixel';
                                folderStatus.style.color = '#000000';
                            }
                        } else {
                            // Versuche "Tanz pixel" als Unterordner zu erstellen
                            selectedFolderHandle = await handle.getDirectoryHandle('Dance pixel', { create: true });
                            if (folderStatus) {
                                folderStatus.textContent = '✓ Folder: Dance pixel (created)';
                                folderStatus.style.color = '#000000';
                            }
                        }
                    }
                } else {
                    // Fallback: Informiere Benutzer
                    if (folderStatus) {
                        folderStatus.textContent = 'Folder selection not available';
                        folderStatus.style.color = '#ff0000';
                    }
                    alert('Folder selection is not available in this browser. Videos will be downloaded.');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Fehler bei Ordner-Auswahl:', error);
                    if (folderStatus) {
                        folderStatus.textContent = 'Error selecting folder';
                        folderStatus.style.color = '#ff0000';
                    }
                }
            }
        }
        
        // Event-Listener für Recording-Controls
        document.addEventListener('DOMContentLoaded', () => {
            const startBtn = document.getElementById('startRecordingBtn');
            const stopBtn = document.getElementById('stopRecordingBtn');
            const selectFolderBtn = document.getElementById('selectFolderBtn');
            
            if (startBtn) {
                startBtn.addEventListener('click', startGridRecording);
            }
            
            if (stopBtn) {
                stopBtn.addEventListener('click', stopGridRecording);
            }
            
            if (selectFolderBtn) {
                selectFolderBtn.addEventListener('click', selectFolder);
            }
        });
        
        // Initialisiere Pose Detection beim Laden
        window.addEventListener('DOMContentLoaded', async () => {
            await initPoseDetection();
        });
        // Info Button Functionality
        const infoButton = document.getElementById('infoButton');
        const infoOverlay = document.getElementById('infoOverlay');
        const infoClose = document.getElementById('infoClose');

        // Automatically open info window on page load with animation
        window.addEventListener('DOMContentLoaded', () => {
            if (infoOverlay) {
                // Small delay to ensure animation is visible
                setTimeout(() => {
                    infoOverlay.classList.add('active');
                }, 50);
            }
        });

        infoButton.addEventListener('click', () => {
            infoOverlay.classList.add('active');
        });

        infoClose.addEventListener('click', () => {
            infoOverlay.classList.remove('active');
        });

        // Close info window when clicking anywhere on the page
        document.addEventListener('click', (e) => {
            if (infoOverlay && infoOverlay.classList.contains('active')) {
                // Don't close if clicking inside the info window
                if (!infoOverlay.querySelector('.info-window').contains(e.target) && e.target !== infoButton) {
                    infoOverlay.classList.remove('active');
                }
            }
        });

        infoOverlay.addEventListener('click', (e) => {
            if (e.target === infoOverlay) {
                infoOverlay.classList.remove('active');
            }
        });
    </script>
</body>
</html>

